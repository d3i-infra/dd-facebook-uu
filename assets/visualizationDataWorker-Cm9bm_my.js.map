{"version":3,"file":"visualizationDataWorker-Cm9bm_my.js","sources":["../src/components/consent_form_viz/visualization_plugin/visualizationDataFunctions/util.ts","../src/components/consent_form_viz/visualization_plugin/visualizationDataFunctions/prepareChartData.ts","../src/components/consent_form_viz/visualization_plugin/visualizationDataFunctions/prepareTextData.ts","../src/components/consent_form_viz/visualization_plugin/visualizationDataFunctions/visualizationDataWorker.ts"],"sourcesContent":["import { DateFormat, Table } from \"../types\";\n\nexport function formatDate(\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString;\n  const dateNumbers = dateString.map((date) => new Date(date).getTime());\n  let domain: [number, number] | null = null;\n  let formatter: (date: Date) => string = (date) => date.toISOString();\n\n  if (format === \"auto\") format = autoFormatDate(dateNumbers, minValues);\n\n  if (format === \"year\") formatter = (date) => date.getFullYear().toString();\n\n  if (format === \"quarter\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const quarter = Math.floor(date.getMonth() / 3) + 1;\n      return `${year}-Q${quarter}`;\n    };\n  }\n\n  if (format === \"month\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      return `${year}-${month}`;\n    };\n  }\n\n  if (format === \"day\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      return `${year}-${month}-${day}`;\n    };\n  }\n\n  if (format === \"hour\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      const hour = date.getHours();\n      return `${year}-${month}-${day} ${hour}:00`;\n    };\n  }\n\n  if (format === \"month_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { month: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any year, starting at january\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2001-01-01\").getTime()];\n  }\n  if (format === \"weekday_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { weekday: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any full week, starting at monday\n    domain = [new Date(\"2023-11-06\").getTime(), new Date(\"2023-11-13\").getTime()];\n  }\n  if (format === \"hour_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { hour: \"numeric\", hour12: false });\n      return intlFormatter.format(date);\n    };\n    // can be any day, starting at midnight\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2000-01-02\").getTime()];\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)));\n  if (domain == null) domain = getDomain(dateNumbers);\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter);\n\n  return [formattedDate, sortableDate];\n}\n\nfunction autoFormatDate(dateNumbers: number[], minValues: number): DateFormat {\n  const [minTime, maxTime] = getDomain(dateNumbers);\n\n  let autoFormat: DateFormat = \"hour\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = \"day\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = \"month\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = \"quarter\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = \"year\";\n\n  return autoFormat;\n}\n\nfunction createSortable(\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {};\n  const [minTime, maxTime] = domain;\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0;\n  if (interval === \"year\") intervalNumber = 1000 * 60 * 60 * 24 * 364;\n  if (interval === \"quarter\") intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3;\n  if ([\"month\", \"month_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28;\n  if ([\"day\", \"weekday_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24;\n  if ([\"hour\", \"hour_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60;\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i);\n      const datestring = formatter(date);\n      if (sortable[datestring] !== undefined) continue;\n      sortable[datestring] = i;\n    }\n  }\n\n  return sortable;\n}\n\nfunction getDomain(numbers: number[]): [number, number] {\n  let min = numbers[0];\n  let max = numbers[0];\n  numbers.forEach((nr) => {\n    if (nr < min) min = nr;\n    if (nr > max) max = nr;\n  });\n  return [min, max];\n}\n\nexport function tokenize(text: string): string[] {\n  const tokens = text.split(\" \");\n  return tokens.filter((token) => /\\p{L}/giu.test(token)); // only tokens with word characters\n}\n\nexport function getTableColumn(table: Table, column: string): string[] {\n  if (column === \".COUNT\") {\n    // special case: just return array with values of 1\n    return Array(table.body.rows.length).fill(\"1\");\n  }\n  const columnIndex = table.head.cells.findIndex((cell) => cell === column);\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`);\n  return table.body.rows.map((row) => row.cells[columnIndex]);\n}\n\nexport function rescaleToRange(value: number, min: number, max: number, newMin: number, newMax: number): number {\n  let scaled = (value - min) / (max - min);\n  scaled = isNaN(scaled) ? 0 : scaled; // prevent NaN\n  return scaled * (newMax - newMin) + newMin;\n}\n\nexport function extractUrlDomain(x: string): string {\n  let domain;\n  try {\n    const url = new URL(x);\n    domain = url.hostname.replace(/^www\\./, \"\").replace(/^m\\./, \"\");\n  } catch (_) {\n    domain = x;\n  }\n  return domain.trim();\n}\n","import { formatDate, getTableColumn } from './util'\nimport { Table, TickerFormat, ChartVisualizationData, ChartVisualization, AxisSettings } from '../types'\n\nexport async function prepareChartData (\n  table: Table,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return { type: visualization.type, xKey: '', xLabel: '', yKeys: {}, data: [] }\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(table, visualization, aggregate)\n}\n\nfunction createVisualizationData (\n  table: Table,\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = initializeVisualizationData(table, visualization)\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        [d.xKey]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction initializeVisualizationData (table: Table, visualization: ChartVisualization): ChartVisualizationData {\n  const yKeys: Record<string, AxisSettings> = {}\n  for (const value of visualization.values) {\n    let tickerFormat: TickerFormat = 'default'\n    if (value.aggregate === 'pct' || value.aggregate === 'count_pct') tickerFormat = 'percent'\n\n    if (value.group_by === undefined) {\n      const label = value.label !== undefined ? value.label : value.column\n      yKeys[value.column] = { id: value.column, label, tickerFormat }\n    } else {\n      const uniqueValues = Array.from(new Set(getTableColumn(table, value.group_by)))\n      for (const uniqueValue of uniqueValues) {\n        const id = `${value.column}.GROUP_BY.${uniqueValue}`\n        yKeys[id] = { id, label: uniqueValue, tickerFormat }\n      }\n    }\n  }\n\n  return {\n    type: visualization.type,\n    xKey: visualization.group.column,\n    xLabel: visualization.group.label,\n    yKeys,\n    data: []\n  }\n}\n\nfunction aggregateData (table: Table, visualization: ChartVisualization): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xKey = visualization.group.column\n\n  const anyAddZeroes = visualization.values.some((value) => value.addZeroes === true)\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xKey,\n        xValue: uniqueValue,\n        values: {}\n      }\n    }\n  }\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by\n    // column values. As suffix we use the value column, separated with .GROUP_BY.. This is used\n    // so that we can relate the aggregated data back to the value specification\n    let yGroup: null | string[] = null\n    if (value.group_by !== undefined) { yGroup = getTableColumn(table, value.group_by).map((v) => `${value.column}.GROUP_BY.${v}`) }\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (Number(xValue) < visualization.group.range[0] || Number(xValue) > visualization.group.range[1]) {\n          continue\n        }\n      }\n\n      const yValue = yValues[i]\n      const group = yGroup != null ? yGroup[i] : value.column\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xKey,\n          xValue: String(xValue),\n          values: {}\n        }\n      }\n\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] = Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  return aggregate\n}\n\nfunction prepareX (\n  table: Table,\n  visualization: ChartVisualization\n): { groupBy: string[], xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xKey: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  tickerFormat?: TickerFormat\n}\n","import { extractUrlDomain, getTableColumn, tokenize } from './util'\nimport { TextVisualizationData, TextVisualization, ScoredTerm, Table } from '../types'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (table: Table, visualization: TextVisualization): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values = visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens = visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (let token of tokens) {\n      if (visualization.extract === 'url_domain') token = extractUrlDomain(token)\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n\n      const v = values != null ? Number(values[i]) ?? 1 : 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (vocabulary: Record<string, VocabularyStats>, nDocs: number, topTerms: number): ScoredTerm[] {\n  return Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = stats.value\n      const idf = Math.log(nDocs / stats.docFreq)\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n}\n","import { ChartVisualization, TextVisualization, VisualizationType, VisualizationData, Table } from '../types'\nimport { prepareChartData } from './prepareChartData'\nimport { prepareTextData } from './prepareTextData'\n\ninterface Input {\n  table: Table\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (table: Table, visualization: VisualizationType): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["formatDate","dateString","format","minValues","formattedDate","dateNumbers","date","domain","formatter","autoFormatDate","year","quarter","month","day","hour","getDomain","sortableDate","createSortable","minTime","maxTime","autoFormat","interval","sortable","intervalNumber","i","datestring","numbers","min","max","nr","tokenize","text","token","getTableColumn","table","column","columnIndex","cell","row","extractUrlDomain","x","prepareChartData","visualization","aggregate","aggregateData","createVisualizationData","visualizationData","initializeVisualizationData","a","b","d","key","yKeys","value","tickerFormat","label","uniqueValues","uniqueValue","id","groupBy","xSortable","prepareX","rowIds","xKey","sortby","aggFun","yValues","yGroup","v","addZeroes","groupSummary","xValue","yValue","group","sortBy","level","prepareTextData","texts","values","vocabulary","getVocabulary","getTopTerms","tokens","seen","nDocs","topTerms","stats","tf","idf","e","error"],"mappings":"yBAEO,SAASA,EACdC,EACAC,EACAC,EAAoB,GACuB,CAC3C,IAAIC,EAA0BH,EAC9B,MAAMI,EAAcJ,EAAW,IAAKK,GAAS,IAAI,KAAKA,CAAI,EAAE,SAAS,EACrE,IAAIC,EAAkC,KAClCC,EAAqCF,GAASA,EAAK,YAAA,EAEnDJ,IAAW,SAAQA,EAASO,EAAeJ,EAAaF,CAAS,GAEjED,IAAW,SAAQM,EAAaF,GAASA,EAAK,YAAA,EAAc,SAAA,GAE5DJ,IAAW,YACbM,EAAaF,GAAS,CACpB,MAAMI,EAAOJ,EAAK,YAAA,EAAc,SAAA,EAC1BK,EAAU,KAAK,MAAML,EAAK,SAAA,EAAa,CAAC,EAAI,EAClD,MAAO,GAAGI,CAAI,KAAKC,CAAO,EAC5B,GAGET,IAAW,UACbM,EAAaF,GAAS,CACpB,MAAMI,EAAOJ,EAAK,YAAA,EAAc,SAAA,EAC1BM,EAAQN,EAAK,eAAe,UAAW,CAAE,MAAO,QAAS,EAC/D,MAAO,GAAGI,CAAI,IAAIE,CAAK,EACzB,GAGEV,IAAW,QACbM,EAAaF,GAAS,CACpB,MAAMI,EAAOJ,EAAK,YAAA,EAAc,SAAA,EAC1BM,EAAQN,EAAK,eAAe,UAAW,CAAE,MAAO,QAAS,EACzDO,EAAMP,EAAK,QAAA,EAAU,SAAA,EAC3B,MAAO,GAAGI,CAAI,IAAIE,CAAK,IAAIC,CAAG,EAChC,GAGEX,IAAW,SACbM,EAAaF,GAAS,CACpB,MAAMI,EAAOJ,EAAK,YAAA,EAAc,SAAA,EAC1BM,EAAQN,EAAK,eAAe,UAAW,CAAE,MAAO,QAAS,EACzDO,EAAMP,EAAK,QAAA,EAAU,SAAA,EACrBQ,EAAOR,EAAK,SAAA,EAClB,MAAO,GAAGI,CAAI,IAAIE,CAAK,IAAIC,CAAG,IAAIC,CAAI,KACxC,GAGEZ,IAAW,gBACbM,EAAaF,GACW,IAAI,KAAK,eAAe,UAAW,CAAE,MAAO,OAAQ,EACrD,OAAOA,CAAI,EAGlCC,EAAS,CAAC,IAAI,KAAK,YAAY,EAAE,UAAW,IAAI,KAAK,YAAY,EAAE,QAAA,CAAS,GAE1EL,IAAW,kBACbM,EAAaF,GACW,IAAI,KAAK,eAAe,UAAW,CAAE,QAAS,OAAQ,EACvD,OAAOA,CAAI,EAGlCC,EAAS,CAAC,IAAI,KAAK,YAAY,EAAE,UAAW,IAAI,KAAK,YAAY,EAAE,QAAA,CAAS,GAE1EL,IAAW,eACbM,EAAaF,GACW,IAAI,KAAK,eAAe,UAAW,CAAE,KAAM,UAAW,OAAQ,GAAO,EACtE,OAAOA,CAAI,EAGlCC,EAAS,CAAC,IAAI,KAAK,YAAY,EAAE,UAAW,IAAI,KAAK,YAAY,EAAE,QAAA,CAAS,GAG9EH,EAAgBC,EAAY,IAAKC,GAASE,EAAU,IAAI,KAAKF,CAAI,CAAC,CAAC,EAC/DC,GAAU,OAAMA,EAASQ,EAAUV,CAAW,GAClD,MAAMW,EAA8CC,EAAeV,EAAQL,EAAQM,CAAS,EAE5F,MAAO,CAACJ,EAAeY,CAAY,CACrC,CAEA,SAASP,EAAeJ,EAAuBF,EAA+B,CAC5E,KAAM,CAACe,EAASC,CAAO,EAAIJ,EAAUV,CAAW,EAEhD,IAAIe,EAAyB,OAC7B,OAAID,EAAUD,EAAU,IAAO,GAAK,GAAK,GAAKf,IAAWiB,EAAa,OAClED,EAAUD,EAAU,IAAO,GAAK,GAAK,GAAK,GAAKf,IAAWiB,EAAa,SACvED,EAAUD,EAAU,IAAO,GAAK,GAAK,GAAK,GAAK,EAAIf,IAAWiB,EAAa,WAC3ED,EAAUD,EAAU,IAAO,GAAK,GAAK,GAAK,IAAMf,IAAWiB,EAAa,QAErEA,CACT,CAEA,SAASH,EACPV,EACAc,EACAb,EAC+B,CAG/B,MAAMc,EAAmC,CAAA,EACnC,CAACJ,EAASC,CAAO,EAAIZ,EAK3B,IAAIgB,EAAyB,EAO7B,GANIF,IAAa,SAAQE,EAAiB,IAAO,GAAK,GAAK,GAAK,KAC5DF,IAAa,YAAWE,EAAiB,IAAO,GAAK,GAAK,GAAK,GAAK,GACpE,CAAC,QAAS,aAAa,EAAE,SAASF,CAAQ,IAAGE,EAAiB,IAAO,GAAK,GAAK,GAAK,IACpF,CAAC,MAAO,eAAe,EAAE,SAASF,CAAQ,IAAGE,EAAiB,IAAO,GAAK,GAAK,IAC/E,CAAC,OAAQ,YAAY,EAAE,SAASF,CAAQ,IAAGE,EAAiB,IAAO,GAAK,IAExEA,EAAiB,EACnB,QAASC,EAAIN,EAASM,GAAKL,EAASK,GAAKD,EAAgB,CACvD,MAAMjB,EAAO,IAAI,KAAKkB,CAAC,EACjBC,EAAajB,EAAUF,CAAI,EAC7BgB,EAASG,CAAU,IAAM,SAC7BH,EAASG,CAAU,EAAID,EACzB,CAGF,OAAOF,CACT,CAEA,SAASP,EAAUW,EAAqC,CACtD,IAAIC,EAAMD,EAAQ,CAAC,EACfE,EAAMF,EAAQ,CAAC,EACnB,OAAAA,EAAQ,QAASG,GAAO,CAClBA,EAAKF,IAAKA,EAAME,GAChBA,EAAKD,IAAKA,EAAMC,EACtB,CAAC,EACM,CAACF,EAAKC,CAAG,CAClB,CAEO,SAASE,EAASC,EAAwB,CAE/C,OADeA,EAAK,MAAM,GAAG,EACf,OAAQC,GAAU,WAAA,SAAA,KAAA,EAAW,KAAKA,CAAK,CAAC,CACxD,CAEO,SAASC,EAAeC,EAAcC,EAA0B,CACrE,GAAIA,IAAW,SAEb,OAAO,MAAMD,EAAM,KAAK,KAAK,MAAM,EAAE,KAAK,GAAG,EAE/C,MAAME,EAAcF,EAAM,KAAK,MAAM,UAAWG,GAASA,IAASF,CAAM,EACxE,GAAIC,EAAc,EAAG,MAAM,IAAI,MAAM,UAAUF,EAAM,EAAE,IAAIC,CAAM,YAAY,EAC7E,OAAOD,EAAM,KAAK,KAAK,IAAKI,GAAQA,EAAI,MAAMF,CAAW,CAAC,CAC5D,CAQO,SAASG,EAAiBC,EAAmB,CAClD,IAAIjC,EACJ,GAAI,CAEFA,EADY,IAAI,IAAIiC,CAAC,EACR,SAAS,QAAQ,SAAU,EAAE,EAAE,QAAQ,OAAQ,EAAE,CAChE,MAAY,CACVjC,EAASiC,CACX,CACA,OAAOjC,EAAO,KAAA,CAChB,CCpKA,eAAsBkC,EACpBP,EACAQ,EACiC,CACjC,GAAIR,EAAM,KAAK,KAAK,SAAW,EAAG,MAAO,CAAE,KAAMQ,EAAc,KAAM,KAAM,GAAI,OAAQ,GAAI,MAAO,CAAA,EAAI,KAAM,EAAC,EAE7G,MAAMC,EAAYC,EAAcV,EAAOQ,CAAa,EACpD,OAAOG,EAAwBX,EAAOQ,EAAeC,CAAS,CAChE,CAEA,SAASE,EACPX,EACAQ,EACAC,EACwB,CACxB,MAAMG,EAAoBC,EAA4Bb,EAAOQ,CAAa,EAE1E,OAAAI,EAAkB,KAAO,OAAO,OAAOH,CAAS,EAC7C,KAAK,CAACK,EAAQC,IAAYD,EAAE,OAASC,EAAE,OAAS,GAAKA,EAAE,OAASD,EAAE,OAAS,EAAI,CAAE,EACjF,IAAKE,GAAM,CACV,UAAWC,KAAO,OAAO,KAAKD,EAAE,MAAM,EAAGA,EAAE,OAAOC,CAAG,EAAI,KAAK,MAAMD,EAAE,OAAOC,CAAG,EAAI,GAAG,EAAI,IAE3F,MAAO,CACL,GAAGD,EAAE,OACL,CAACA,EAAE,IAAI,EAAGA,EAAE,OACZ,SAAUA,EAAE,OACZ,SAAUA,EAAE,MAAA,CAEhB,CAAC,EAEIJ,CACT,CAEA,SAASC,EAA6Bb,EAAcQ,EAA2D,CAC7G,MAAMU,EAAsC,CAAA,EAC5C,UAAWC,KAASX,EAAc,OAAQ,CACxC,IAAIY,EAA6B,UAGjC,IAFID,EAAM,YAAc,OAASA,EAAM,YAAc,eAAaC,EAAe,WAE7ED,EAAM,WAAa,OAAW,CAChC,MAAME,EAAQF,EAAM,QAAU,OAAYA,EAAM,MAAQA,EAAM,OAC9DD,EAAMC,EAAM,MAAM,EAAI,CAAE,GAAIA,EAAM,OAAQ,MAAAE,EAAO,aAAAD,CAAA,CACnD,KAAO,CACL,MAAME,EAAe,MAAM,KAAK,IAAI,IAAIvB,EAAeC,EAAOmB,EAAM,QAAQ,CAAC,CAAC,EAC9E,UAAWI,KAAeD,EAAc,CACtC,MAAME,EAAK,GAAGL,EAAM,MAAM,aAAaI,CAAW,GAClDL,EAAMM,CAAE,EAAI,CAAE,GAAAA,EAAI,MAAOD,EAAa,aAAAH,CAAA,CACxC,CACF,CACF,CAEA,MAAO,CACL,KAAMZ,EAAc,KACpB,KAAMA,EAAc,MAAM,OAC1B,OAAQA,EAAc,MAAM,MAC5B,MAAAU,EACA,KAAM,CAAA,CAAC,CAEX,CAEA,SAASR,EAAeV,EAAcQ,EAA0E,CAC9G,MAAMC,EAAmD,CAAA,EAEnD,CAAE,QAAAgB,EAAS,UAAAC,CAAA,EAAcC,EAAS3B,EAAOQ,CAAa,EACtDoB,EAAS5B,EAAM,KAAK,KAAK,IAAKI,GAAQA,EAAI,EAAE,EAC5CyB,EAAOrB,EAAc,MAAM,OAGjC,GADqBA,EAAc,OAAO,KAAMW,GAAUA,EAAM,YAAc,EAAI,GAC9DO,GAAa,KAC/B,SAAW,CAACH,EAAaO,CAAM,IAAK,OAAO,QAAQJ,CAAS,EAC1DjB,EAAUc,CAAW,EAAI,CACvB,OAAQO,EACR,OAAQ,CAAA,EACR,KAAAD,EACA,OAAQN,EACR,OAAQ,CAAA,CAAC,EAKf,UAAWJ,KAASX,EAAc,OAAQ,CAGxC,MAAMuB,EAASZ,EAAM,YAAc,OAAYA,EAAM,UAAY,QAE3Da,EAAUjC,EAAeC,EAAOmB,EAAM,MAAM,EAClD,GAAIa,EAAQ,SAAW,EAAG,MAAM,IAAI,MAAM,YAAYhC,EAAM,EAAE,IAAImB,EAAM,MAAM,YAAY,EAK1F,IAAIc,EAA0B,KAC1Bd,EAAM,WAAa,SAAac,EAASlC,EAAeC,EAAOmB,EAAM,QAAQ,EAAE,IAAKe,GAAM,GAAGf,EAAM,MAAM,aAAae,CAAC,EAAE,GAG7H,MAAMC,EAAYhB,EAAM,WAAa,GAC/BiB,EAA2D,CAAA,EAEjE,QAAS,EAAI,EAAG,EAAIR,EAAO,OAAQ,IAAK,CAEtC,MAAMS,EAASZ,EAAQ,CAAC,EAExB,GAAIjB,EAAc,MAAM,QAAU,SAC5B,OAAO6B,CAAM,EAAI7B,EAAc,MAAM,MAAM,CAAC,GAAK,OAAO6B,CAAM,EAAI7B,EAAc,MAAM,MAAM,CAAC,GAC/F,SAIJ,MAAM8B,EAASN,EAAQ,CAAC,EAClBO,EAAQN,GAAU,KAAOA,EAAO,CAAC,EAAId,EAAM,OAE3CqB,EAASd,GAAa,KAAOA,EAAUW,CAAM,EAAIZ,EAAQ,CAAC,EAG5DW,EAAaG,CAAK,IAAM,SAAWH,EAAaG,CAAK,EAAI,CAAE,EAAG,EAAG,IAAK,CAAA,IACtER,IAAW,aAAeA,IAAW,UAAQK,EAAaG,CAAK,EAAE,GAAK,GACtER,IAAW,QAAOK,EAAaG,CAAK,EAAE,KAAO,OAAOD,CAAM,GAAK,GAE/D7B,EAAU4B,CAAM,IAAM,SACxB5B,EAAU4B,CAAM,EAAI,CAClB,OAAAG,EACA,OAAQ,CAAA,EACR,KAAAX,EACA,OAAQ,OAAOQ,CAAM,EACrB,OAAQ,CAAA,CAAC,GAIT5B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,IAAM,SAAW9B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,EAAI,CAAA,GACrF9B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,EAAE,KAAKX,EAAO,CAAC,CAAC,EAE1CnB,EAAU4B,CAAM,EAAE,OAAOE,CAAK,IAAM,SAAW9B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,EAAI,IACjFR,IAAW,SAAWA,IAAW,iBAAuBM,CAAM,EAAE,OAAOE,CAAK,GAAK,IACjFR,IAAW,OAASA,IAAW,QAAUA,IAAW,SACtDtB,EAAU4B,CAAM,EAAE,OAAOE,CAAK,GAAK,OAAOD,CAAM,GAAK,EAEzD,CAGA,OAAO,KAAKF,CAAY,EAAE,QAASG,GAAU,CAC3C,UAAWF,KAAU,OAAO,KAAK5B,CAAS,EAAG,CAC3C,GAAIA,EAAU4B,CAAM,EAAE,OAAOE,CAAK,IAAM,OACtC,GAAIJ,EAAW1B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,EAAI,MAC5C,UAEHR,IAAW,SACbtB,EAAU4B,CAAM,EAAE,OAAOE,CAAK,EAAI,OAAO9B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,CAAC,EAAIH,EAAaG,CAAK,EAAE,GAE9FR,IAAW,cACbtB,EAAU4B,CAAM,EAAE,OAAOE,CAAK,EAAK,IAAM,OAAO9B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,CAAC,EAAKH,EAAaG,CAAK,EAAE,GAEtGR,IAAW,QACbtB,EAAU4B,CAAM,EAAE,OAAOE,CAAK,EAAK,IAAM,OAAO9B,EAAU4B,CAAM,EAAE,OAAOE,CAAK,CAAC,EAAKH,EAAaG,CAAK,EAAE,IAE5G,CACF,CAAC,CACH,CAEA,OAAO9B,CACT,CAEA,SAASkB,EACP3B,EACAQ,EAC0E,CAC1E,IAAIiB,EAAU1B,EAAeC,EAAOQ,EAAc,MAAM,MAAM,EAC9D,GAAIiB,EAAQ,SAAW,EACrB,MAAM,IAAI,MAAM,YAAYzB,EAAM,EAAE,IAAIQ,EAAc,MAAM,MAAM,YAAY,EAGhF,IAAIkB,EAAoD,KAOxD,GAJIlB,EAAc,MAAM,aAAe,SACpC,CAACiB,EAASC,CAAS,EAAI5D,EAAW2D,EAASjB,EAAc,MAAM,UAAU,GAGxEA,EAAc,MAAM,SAAW,OAAW,CAC5CkB,EAAY,CAAA,EAEZ,QAASpC,EAAI,EAAGA,EAAIkB,EAAc,MAAM,OAAO,OAAQlB,IAAK,CAC1D,MAAMmD,EAAQjC,EAAc,MAAM,OAAOlB,CAAC,EAC1CoC,EAAUe,CAAK,EAAInD,CACrB,CACF,CAEA,MAAO,CAAE,QAAAmC,EAAS,UAAAC,CAAA,CACpB,CCtLA,eAAsBgB,EAAiB1C,EAAcQ,EAAkE,CACrH,MAAMI,EAA2C,CAC/C,KAAMJ,EAAc,KACpB,SAAU,CAAA,CAAC,EAGb,GAAIR,EAAM,KAAK,KAAK,SAAW,EAAG,OAAOY,EAEzC,MAAM+B,EAAQ5C,EAAeC,EAAOQ,EAAc,UAAU,EACtDoC,EAASpC,EAAc,aAAe,KAAOT,EAAeC,EAAOQ,EAAc,WAAW,EAAI,KAEhGqC,EAAaC,EAAcH,EAAOC,EAAQpC,CAAa,EAC7D,OAAAI,EAAkB,SAAWmC,EAAYF,EAAYF,EAAM,OAAQ,GAAG,EAE/D/B,CACT,CAEA,SAASkC,EACPH,EACAC,EACApC,EACiC,CACjC,MAAMqC,EAA8C,CAAA,EAEpD,QAASvD,EAAI,EAAGA,EAAIqD,EAAM,OAAQrD,IAAK,CACrC,GAAIqD,IAAQrD,CAAC,GAAK,KAAM,SACxB,MAAMO,EAAO8C,EAAMrD,CAAC,EACd0D,EAASxC,EAAc,UAAY,MAAQA,EAAc,SAAWZ,EAASC,CAAI,EAAI,CAACA,CAAI,EAE1FoD,MAAW,IACjB,QAASnD,KAASkD,EAAQ,CACpBxC,EAAc,UAAY,eAAcV,EAAQO,EAAiBP,CAAK,GACtE+C,EAAW/C,CAAK,IAAM,SAAW+C,EAAW/C,CAAK,EAAI,CAAE,MAAO,EAAG,QAAS,CAAA,GACzEmD,EAAK,IAAInD,CAAK,IACjB+C,EAAW/C,CAAK,EAAE,SAAW,EAC7BmD,EAAK,IAAInD,CAAK,GAGhB,MAAMoC,EAAIU,GAAU,KAAO,OAAOA,EAAOtD,CAAC,CAAC,GAAK,EAAI,EAC/C,MAAM4C,CAAC,IAAGW,EAAW/C,CAAK,EAAE,OAASoC,EAC5C,CACF,CACA,OAAOW,CACT,CAEA,SAASE,EAAaF,EAA6CK,EAAeC,EAAgC,CAChH,OAAO,OAAO,QAAQN,CAAU,EAC7B,IAAI,CAAC,CAAChD,EAAMuD,CAAK,IAAM,CACtB,MAAMC,EAAKD,EAAM,MACXE,EAAM,KAAK,IAAIJ,EAAQE,EAAM,OAAO,EAC1C,MAAO,CAAE,KAAAvD,EAAM,MAAOuD,EAAM,MAAO,WAAYC,EAAKC,CAAA,CACtD,CAAC,EACA,KAAK,CAACxC,EAAGC,IAAMA,EAAE,WAAaD,EAAE,UAAU,EAC1C,MAAM,EAAGqC,CAAQ,CACtB,CCrDA,KAAK,UAAaI,GAA2B,CAC3C5C,EAAwB4C,EAAE,KAAK,MAAOA,EAAE,KAAK,aAAa,EACvD,KAAM3C,GAAsB,CAC3B,KAAK,YAAY,CAAE,OAAQ,UAAW,kBAAAA,EAAmB,CAC3D,CAAC,EACA,MAAO4C,GAAU,CAChB,QAAQ,MAAMA,CAAK,EACnB,KAAK,YAAY,CAAE,OAAQ,QAAS,kBAAmB,OAAW,CACpE,CAAC,CACL,EAEA,eAAe7C,EAAyBX,EAAcQ,EAA8D,CAClH,GAAIR,IAAU,QAAaQ,IAAkB,OAAW,MAAM,IAAI,MAAM,sCAAsC,EAE9G,GAAI,CAAC,OAAQ,MAAO,MAAM,EAAE,SAASA,EAAc,IAAI,EAAK,OAAO,MAAMD,EAAiBP,EAAOQ,CAAmC,EAEpI,GAAI,CAAC,WAAW,EAAE,SAASA,EAAc,IAAI,EAAK,OAAO,MAAMkC,EAAgB1C,EAAOQ,CAAkC,EAExH,MAAM,IAAI,MAAM,sBAAsBA,EAAc,IAAI,gBAAgB,CAC1E"}